<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>通过rebar3创建Erlang应用</title>
    <link href="undefined2019/12/17/%E9%80%9A%E8%BF%87rebar3%E5%88%9B%E5%BB%BAerlang%E5%BA%94%E7%94%A8/"/>
    <url>2019/12/17/%E9%80%9A%E8%BF%87rebar3%E5%88%9B%E5%BB%BAerlang%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://praglowski.com/2016/05/10/your-first-erlang-application-with-rebar3" target="_blank" rel="noopener">https://praglowski.com/2016/05/10/your-first-erlang-application-with-rebar3</a><br><a href="https://github.com/erlang/rebar3/issues/1740" target="_blank" rel="noopener">https://github.com/erlang/rebar3/issues/1740</a><br><a href="https://www.rebar3.org/docs/basic-usage" target="_blank" rel="noopener">https://www.rebar3.org/docs/basic-usage</a></p><h3 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h3><h4 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h4><p>根据目标，这里创建<code>app</code>类型的应用，当然也可以创建<code>escript、lib、release、plugin</code>类型的应用，这个要根据实际情况而定。关于应用类型，详情参考 <a href="https://www.rebar3.org/docs/basic-usage" target="_blank" rel="noopener">docs.basic-usage</a></p><pre><code>➜  projects rebar3 new app transaction_publish_service===&gt; Writing transaction_publish_service/src/transaction_publish_service_app.erl===&gt; Writing transaction_publish_service/src/transaction_publish_service_sup.erl===&gt; Writing transaction_publish_service/src/transaction_publish_service.app.src===&gt; Writing transaction_publish_service/rebar.config===&gt; Writing transaction_publish_service/.gitignore===&gt; Writing transaction_publish_service/LICENSE===&gt; Writing transaction_publish_service/README.md</code></pre><h4 id="修改rebar-config，增加依赖"><a href="#修改rebar-config，增加依赖" class="headerlink" title="修改rebar.config，增加依赖"></a>修改rebar.config，增加依赖</h4><pre><code>➜  transaction_publish_service cat rebar.config {erl_opts, [debug_info]}.{deps, [{emqtt, {git, &quot;https://github.com/emqx/emqtt&quot;, {tag, &quot;v1.0.0&quot;}}}]}.{shell, [  % {config, &quot;config/sys.config&quot;},    {apps, [transaction_publish_service]}]}.➜  transaction_publish_service </code></pre><h4 id="编译构建"><a href="#编译构建" class="headerlink" title="编译构建"></a>编译构建</h4><pre><code>➜  transaction_publish_service rebar3 compile===&gt; Verifying dependencies...===&gt; Fetching emqtt (from {git,&quot;https://github.com/emqx/emqtt&quot;,{tag,&quot;v1.0.0&quot;}})===&gt; Fetching gun v1.3.0===&gt; Version cached at /home/marco/.cache/rebar3/hex/hexpm/packages/gun-1.3.0.tar is up to date, reusing it===&gt; Fetching cowlib v2.6.0===&gt; Version cached at /home/marco/.cache/rebar3/hex/hexpm/packages/cowlib-2.6.0.tar is up to date, reusing it===&gt; Compiling cowlib===&gt; Compiling gun===&gt; Compiling emqtt===&gt; Compiling transaction_publish_service➜  transaction_publish_service ls_build  LICENSE  README.md  rebar.config  rebar.lock  src➜  transaction_publish_service tree _build _build└── default    └── lib        ├── cowlib        │   ├── ebin        │   │   ├── cow_base64url.beam        │   │   ├── cow_cookie.beam        │   │   ├── cow_date.beam        │   │   ├── cow_hpack.beam        │   │   ├── cow_http2.beam        │   │   ├── cow_http.beam        │   │   ├── cow_http_hd.beam        │   │   ├── cow_http_te.beam        │   │   ├── cow_iolists.beam        │   │   ├── cowlib.app        │   │   ├── cow_mimetypes.beam        │   │   ├── cow_multipart.beam        │   │   ├── cow_qs.beam        │   │   ├── cow_spdy.beam        │   │   ├── cow_sse.beam        │   │   ├── cow_uri.beam        │   │   └── cow_ws.beam        │   ├── erlang.mk        │   ├── hex_metadata.config        │   ├── include        │   │   ├── cow_inline.hrl        │   │   └── cow_parse.hrl        │   ├── LICENSE        │   ├── Makefile        │   ├── README.asciidoc        │   └── src        │       ├── cow_base64url.erl        │       ├── cow_cookie.erl        │       ├── cow_date.erl        │       ├── cow_hpack.erl        │       ├── cow_http2.erl        │       ├── cow_http.erl        │       ├── cow_http_hd.erl        │       ├── cow_http_te.erl        │       ├── cow_iolists.erl        │       ├── cowlib.app.src        │       ├── cow_mimetypes.erl        │       ├── cow_mimetypes.erl.src        │       ├── cow_multipart.erl        │       ├── cow_qs.erl        │       ├── cow_spdy.erl        │       ├── cow_spdy.hrl        │       ├── cow_sse.erl        │       ├── cow_uri.erl        │       └── cow_ws.erl        ├── emqtt        │   ├── ebin        │   │   ├── emqtt.app        │   │   ├── emqtt.beam        │   │   ├── emqtt_frame.beam        │   │   ├── emqtt_props.beam        │   │   ├── emqtt_sock.beam        │   │   └── emqtt_ws.beam        │   ├── include        │   │   └── emqtt.hrl        │   ├── LICENSE        │   ├── Makefile        │   ├── pre-compile        │   ├── README.md        │   ├── rebar.config        │   ├── rebar.config.script        │   ├── src        │   │   ├── emqtt.app.src        │   │   ├── emqtt.erl        │   │   ├── emqtt_frame.erl        │   │   ├── emqtt_props.erl        │   │   ├── emqtt_sock.erl        │   │   └── emqtt_ws.erl        │   ├── test        │   │   └── emqtt_frame_SUITE.erl        │   └── TODO        ├── gun        │   ├── ebin        │   │   ├── gun.app        │   │   ├── gun_app.beam        │   │   ├── gun.beam        │   │   ├── gun_content_handler.beam        │   │   ├── gun_data_h.beam        │   │   ├── gun_http2.beam        │   │   ├── gun_http.beam        │   │   ├── gun_sse_h.beam        │   │   ├── gun_sup.beam        │   │   ├── gun_tcp.beam        │   │   ├── gun_tls.beam        │   │   ├── gun_ws.beam        │   │   └── gun_ws_h.beam        │   ├── erlang.mk        │   ├── hex_metadata.config        │   ├── LICENSE        │   ├── Makefile        │   ├── README.asciidoc        │   ├── rebar.config        │   └── src        │       ├── gun_app.erl        │       ├── gun.app.src        │       ├── gun_content_handler.erl        │       ├── gun_data_h.erl        │       ├── gun.erl        │       ├── gun_http2.erl        │       ├── gun_http.erl        │       ├── gun_sse_h.erl        │       ├── gun_sup.erl        │       ├── gun_tcp.erl        │       ├── gun_tls.erl        │       ├── gun_ws.erl        │       └── gun_ws_h.erl        └── transaction_publish_service            ├── ebin            │   ├── transaction_publish_service.app            │   ├── transaction_publish_service_app.beam            │   └── transaction_publish_service_sup.beam            ├── include -&gt; ../../../../include            ├── priv -&gt; ../../../../priv            └── src -&gt; ../../../../src17 directories, 101 files➜  transaction_publish_service </code></pre><h4 id="escript类型的应用创建"><a href="#escript类型的应用创建" class="headerlink" title="escript类型的应用创建"></a>escript类型的应用创建</h4><pre><code>➜  erlang rebar3 new escript hello===&gt; Writing hello/src/hello.erl===&gt; Writing hello/src/hello.app.src===&gt; Writing hello/rebar.config===&gt; Writing hello/.gitignore===&gt; Writing hello/LICENSE===&gt; Writing hello/README.md➜  erlang lsemqtt  emqx  emqx-rel  erlang-learning  file_client  file_service  hello  helloworld  jaerlang2  learn-you-some-erlang  tutorails➜  erlang cd hello➜  hello lsLICENSE  README.md  rebar.config  src➜  hello cd src ➜  src lshello.app.src  hello.erl➜  src cat hello.erl -module(hello).%% API exports-export([main/1]).%%====================================================================%% API functions%%====================================================================%% escript Entry pointmain(Args) -&gt;    io:format(&quot;Args: ~p~n&quot;, [Args]),    erlang:halt(0).%%====================================================================%% Internal functions%%====================================================================➜  src cd .,.           cd: no such file or directory: .,.➜  src cd ..➜  hello lsLICENSE  README.md  rebar.config  src➜  hello rebar3 escriptize===&gt; Verifying dependencies...===&gt; Compiling hello===&gt; Building escript...➜  hello _build/default/bin/hello  Args: []➜  hello _build/default/bin/hello helloworldArgs: [&quot;helloworld&quot;]➜  hello </code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu16.04&amp;14.04下的docker安装</title>
    <link href="undefined2019/12/11/Docker%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/"/>
    <url>2019/12/11/Docker%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h4 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h4><pre><code>$ sudo apt-get remove docker docker-engine docker.io</code></pre><h4 id="安装linux的额外镜像包（仅ubuntu14-04需要）"><a href="#安装linux的额外镜像包（仅ubuntu14-04需要）" class="headerlink" title="安装linux的额外镜像包（仅ubuntu14.04需要）"></a>安装linux的额外镜像包（仅ubuntu14.04需要）</h4><p>执行如下操作，允许你使用aufs存储驱动。ubuntu16.04使用默认的overlay2存储驱动。</p><pre><code>$ sudo apt-get update$ sudo apt-get install \    linux-image-extra-$(uname -r) \    linux-image-extra-virtual</code></pre><h4 id="设置安装源"><a href="#设置安装源" class="headerlink" title="设置安装源"></a>设置安装源</h4><p>通过如下步骤，设置安装源仓库，这里我们使用阿里源</p><pre><code>$ sudo apt-get update$ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common$ curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -  $ sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</code></pre><h4 id="安装docker社区版"><a href="#安装docker社区版" class="headerlink" title="安装docker社区版"></a>安装docker社区版</h4><p>通过如下命令将安装docker最新版本</p><pre><code>$ sudo apt-get update$ sudo apt-get install docker-ce</code></pre><h4 id="检验是否安装成功"><a href="#检验是否安装成功" class="headerlink" title="检验是否安装成功"></a>检验是否安装成功</h4><p>通过运行hello-world实例便可检验是否安装成功</p><pre><code>$ sudo docker run hello-world</code></pre><h4 id="创建一个docker用户组-可选"><a href="#创建一个docker用户组-可选" class="headerlink" title="创建一个docker用户组(可选)"></a>创建一个docker用户组(可选)</h4><p>docker后台进程是绑定的Unix的socket而不是TCP端口。默认情况下，Unix的socket属于用户root，其它用户要使用要通过sudo命令。由于这个原因，docker daemon通常使用root用户运行。</p><p>　　为了避免使用sudo当你使用docker命令的时候，创建一个Unix组名为docker并且添加用户。当docker daemon启动，它会分配Unix socket读写权限给所属的docker组。</p><pre><code>$ sudo groupadd docker$ sudo usermod -aG docker $USER</code></pre><p>校验生效。通过运行docker命令不带sudo：docker run hello-world，如果失败会有以下类似的信息：Cannot connect to the Docker daemon. Is ‘docker daemon’ running on this host?确保DOCKER_HOST环境变量没有设置。如果有取消它。</p><h2 id="卸载方法"><a href="#卸载方法" class="headerlink" title="卸载方法"></a>卸载方法</h2><h4 id="卸载docker社区版"><a href="#卸载docker社区版" class="headerlink" title="卸载docker社区版:"></a>卸载docker社区版:</h4><pre><code>$ sudo apt-get purge docker-ce </code></pre><h4 id="删除镜像、容器、卷"><a href="#删除镜像、容器、卷" class="headerlink" title="删除镜像、容器、卷"></a>删除镜像、容器、卷</h4><pre><code>$ sudo rm -rf /var/lib/docker</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Install Docker in ubuntu</a><br><a href="https://www.cnblogs.com/lighten/p/6034984.html" target="_blank" rel="noopener">ubuntu16.04安装docker</a>  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/12/11/hello-world/"/>
    <url>2019/12/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于docker的Spark on Mesos部署</title>
    <link href="undefined2019/12/11/%E5%9F%BA%E4%BA%8Edocker%E7%9A%84%20spark%20on%20mesos%20%E9%83%A8%E7%BD%B2/"/>
    <url>2019/12/11/%E5%9F%BA%E4%BA%8Edocker%E7%9A%84%20spark%20on%20mesos%20%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="前提概要"><a href="#前提概要" class="headerlink" title="前提概要"></a>前提概要</h3><h4 id="储备"><a href="#储备" class="headerlink" title="储备"></a>储备</h4><p>已搭好一个三台Zookeeper的集群，相关信息如下：<br>主机系统 | ip地址 | ID<br>— | — | —<br>ubuntu16.04 server | 192.168.24.173 | 1<br>ubuntu16.04 server | 192.168.24.179 | 2<br>ubuntu16.04 server | 192.168.24.178 | 3</p><h4 id="平台软件版本规划"><a href="#平台软件版本规划" class="headerlink" title="平台软件版本规划"></a>平台软件版本规划</h4><table><thead><tr><th>软件</th><th>版本</th></tr></thead><tbody><tr><td>zookeeper</td><td>3.4.13</td></tr><tr><td>mesos</td><td>1.6.1</td></tr><tr><td>spark</td><td>2.2.2</td></tr></tbody></table><h3 id="Mesos部署"><a href="#Mesos部署" class="headerlink" title="Mesos部署"></a>Mesos部署</h3><h4 id="拉取docker镜像"><a href="#拉取docker镜像" class="headerlink" title="拉取docker镜像"></a>拉取docker镜像</h4><h5 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h5><p>master: <a href="https://hub.docker.com/r/mesosphere/mesos-master/" target="_blank" rel="noopener">mesosphere/mesos-master</a><br>slave: <a href="https://hub.docker.com/r/mesosphere/mesos-slave/" target="_blank" rel="noopener">mesosphere/mesos-slave</a></p><h5 id="拉镜像"><a href="#拉镜像" class="headerlink" title="拉镜像"></a>拉镜像</h5><pre><code>$ docker pull mesosphere/mesos-master:1.6.1-rc2$ docker pull mesosphere/mesos-master:1.6.1-rc2</code></pre><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><h5 id="设置host"><a href="#设置host" class="headerlink" title="设置host"></a>设置host</h5><p>分别登陆三台服务器设置主机ip到环境变量，或者在启动mesos的参数中设置，本次我们选择在启动参数中设置。</p><pre><code>$ HOST_IP=192.168.24.17x</code></pre><h5 id="master"><a href="#master" class="headerlink" title="master"></a>master</h5><pre><code>$ docker run -d --net=host --restart always --name m1 \  -e MESOS_PORT=5050 \  -e MESOS_HOSTNAME=192.168.24.173 \  -e MESOS_IP=192.168.24.173 \  -e MESOS_ZK=zk://192.168.24.173:2181,192.168.24.179:2181,192.168.24.178:2181/mesos \  -e MESOS_QUORUM=2 \  -e MESOS_REGISTRY=in_memory \  -e MESOS_LOG_DIR=/var/log/mesos \  -e MESOS_WORK_DIR=/var/tmp/mesos \  -v &quot;$(pwd)/log/mesos:/var/log/mesos&quot; \  -v &quot;$(pwd)/tmp/mesos:/var/tmp/mesos&quot; \  mesosphere/mesos-master:1.5.0</code></pre><pre><code>$ docker run -d --net=host --restart always --name m2 \  -e MESOS_PORT=5050 \  -e MESOS_HOSTNAME=192.168.24.179 \  -e MESOS_IP=192.168.24.179 \  -e MESOS_ZK=zk://192.168.24.173:2181,192.168.24.179:2181,192.168.24.178:2181/mesos \  -e MESOS_QUORUM=2 \  -e MESOS_REGISTRY=in_memory \  -e MESOS_LOG_DIR=/var/log/mesos \  -e MESOS_WORK_DIR=/var/tmp/mesos \  -v &quot;$(pwd)/log/mesos:/var/log/mesos&quot; \  -v &quot;$(pwd)/tmp/mesos:/var/tmp/mesos&quot; \  mesosphere/mesos-master:1.5.0</code></pre><pre><code>$ docker run -d --net=host --restart always --name m3 \  -e MESOS_PORT=5050 \  -e MESOS_HOSTNAME=192.168.24.178 \  -e MESOS_IP=192.168.24.178 \  -e MESOS_ZK=zk://192.168.24.173:2181,192.168.24.179:2181,192.168.24.178:2181/mesos \  -e MESOS_QUORUM=2 \  -e MESOS_REGISTRY=in_memory \  -e MESOS_LOG_DIR=/var/log/mesos \  -e MESOS_WORK_DIR=/var/tmp/mesos \  -v &quot;$(pwd)/log/mesos:/var/log/mesos&quot; \  -v &quot;$(pwd)/tmp/mesos:/var/tmp/mesos&quot; \  mesosphere/mesos-master:1.5.0</code></pre><h5 id="marathon"><a href="#marathon" class="headerlink" title="marathon"></a>marathon</h5><p>192.168.24.178下部署marathon:</p><pre><code>$ docker run -d --net=host --restart always --privileged \  --name mm3 \  mesosphere/marathon:latest \  --master zk://192.168.24.173:2181,192.168.24.179:2181,192.168.24.178:2181/mesos \  --zk zk://92.168.24.173:2181,192.168.24.179:2181,192.168.24.178:2181/marathon \  --http_port 8089 \  --http_address 192.168.24.178 </code></pre><h5 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h5><p>在192.168.24.173下暂时不部署slave，但预留命名m1s1和m1s2. </p><pre><code>$ docker run -it -d --restart always --net=host --name m1s1 --privileged \  -e MESOS_PORT=5051 \  -e MESOS_HOSTNAME=192.168.24.173 \  -e MESOS_IP=192.168.24.173 \  -e MESOS_MASTER=zk://192.168.24.173:2181,192.168.24.179:2181,192.168.24.178:2181/mesos \  -e MESOS_CONTAINERIZERS=docker,mesos \  -e MESOS_LOG_DIR=/var/log/mesos \  -e MESOS_WORK_DIR=/var/tmp/mesos \  -v &quot;$(pwd)/log/mesos:/var/log/mesos&quot; \  -v &quot;$(pwd)/tmp/mesos:/var/tmp/mesos&quot; \  mesosphere/mesos-slave:1.6.1-rc2</code></pre><pre><code>$ docker run -it -d --restart always --net=host --name m1s2 --privileged \  -e MESOS_PORT=5052 \  -e MESOS_MASTER=zk://192.168.24.173:2181,192.168.24.179:2181,192.168.24.178:2181/mesos \  -e MESOS_LOG_DIR=/var/log/mesos \  -e MESOS_WORK_DIR=/var/tmp/mesos \  -v &quot;$(pwd)/log/mesos:/var/log/mesos&quot; \  -v &quot;$(pwd)/tmp/mesos:/var/tmp/mesos&quot; \  mesosphere/mesos-slave:1.6.1-rc2</code></pre><p>在192.168.24.179下启动2个slave，分别命名为m2s1和m2s2.</p><pre><code>$ docker run -it -d --restart always --net=host \  --name m2s1 \  --privileged \  -e MESOS_PORT=5051 \  -e MESOS_MASTER=zk://192.168.24.173:2181,192.168.24.179:2181,192.168.24.178:2181/mesos \  -e MESOS_SWITCH_USER=0 \  -e MESOS_CONTAINERIZERS=docker,mesos \  -e MESOS_LOG_DIR=/var/log/mesos \  -e MESOS_WORK_DIR=/var/tmp/mesos \  -v &quot;$(pwd)/log/mesos:/var/log/mesos&quot; \  -v &quot;$(pwd)/tmp/mesos:/var/tmp/mesos&quot; \  -v /var/run/docker.sock:/var/run/docker.sock \  -v /cgroup:/cgroup \  -v /sys:/sys \  -v /usr/local/bin/docker:/usr/local/bin/docker \  mesosphere/mesos-slave:1.5.0 \  --ip=192.168.24.179 </code></pre><pre><code>$ docker run -it -d --restart always --net=host --name m2s2 --privileged \  -e MESOS_PORT=5052 \  -e MESOS_MASTER=zk://192.168.24.173:2181,192.168.24.179:2181,192.168.24.178:2181/mesos \  -e MESOS_LOG_DIR=/var/log/mesos \  -e MESOS_WORK_DIR=/var/tmp/mesos \  -v &quot;$(pwd)/log/mesos:/var/log/mesos&quot; \  -v &quot;$(pwd)/tmp/mesos:/var/tmp/mesos&quot; \  mesosphere/mesos-slave:1.6.1-rc2</code></pre><pre><code>$ docker run -it -d --restart always --net=host --name m2s3 --privileged \  -e MESOS_PORT=5053 \  -e MESOS_MASTER=zk://192.168.24.173:2181,192.168.24.179:2181,192.168.24.178:2181/mesos \  -e MESOS_SWITCH_USER=0 \  -e MESOS_CONTAINERIZERS=docker,mesos \  -e MESOS_LOG_DIR=/var/log/mesos \  -e MESOS_WORK_DIR=/var/tmp/mesos \  -v &quot;$(pwd)/log/mesos:/var/log/mesos&quot; \  -v &quot;$(pwd)/tmp/mesos:/var/tmp/mesos&quot; \  -v /var/run/docker.sock:/var/run/docker.sock \  -v /cgroup:/cgroup \  -v /sys:/sys \  -v /usr/local/bin/docker:/usr/local/bin/docker \  mesosphere/mesos-slave:1.6.1-rc2 \  --ip=192.168.24.179 \  --launcher=posix</code></pre><pre><code>docker run -d --net=host --privileged \  --name mesos_slave \  -e MESOS_PORT=5051 \  -e MESOS_MASTER=zk://192.168.24.179:2181/mesos \  -e MESOS_SWITCH_USER=0 \  -e MESOS_CONTAINERIZERS=docker,mesos \  -e MESOS_LOG_DIR=/var/log/mesos \  -e MESOS_WORK_DIR=/var/tmp/mesos \  -v &quot;$(pwd)/log/mesos:/var/log/mesos&quot; \  -v &quot;$(pwd)/tmp/mesos:/var/tmp/mesos&quot; \  -v /var/run/docker.sock:/var/run/docker.sock \  -v /sys/fs/cgroup:/cgroup \  -v /sys:/sys \  -v /usr/bin/docker:/usr/local/bin/docker \  mesosphere/mesos-slave:1.1.0-2.0.107.ubuntu1404 \  --ip=192.168.24.179 \  --launcher=posix</code></pre><p>在192.168.24.178下启动2个slave，分别命名为m3s1和m3s2.</p><pre><code>$ docker run -it -d --restart always --net=host --name m3s1 --privileged \  -e MESOS_PORT=5053 \  -e MESOS_HOSTNAME=192.168.24.178 \  -e MESOS_IP=192.168.24.178 \  -e MESOS_MASTER=zk://192.168.24.173:2181,192.168.24.179:2181,192.168.24.178:2181/mesos \  -e MESOS_CONTAINERIZERS=docker,mesos \  -e MESOS_LOG_DIR=/var/log/mesos \  -e MESOS_WORK_DIR=/var/tmp/mesos \  -v &quot;$(pwd)/log/mesos:/var/log/mesos&quot; \  -v &quot;$(pwd)/tmp/mesos:/var/tmp/mesos&quot; \  -v /var/run/docker.sock:/var/run/docker.sock \  -v /cgroup:/cgroup \  -v /sys:/sys \  -v /usr/local/bin/docker:/usr/local/bin/docker \  mesosphere/mesos-slave:1.6.1-rc2</code></pre><pre><code>$ docker run -it -d --restart always --net=host --name m3s2 --privileged \  -e MESOS_PORT=5052 \   -e MESOS_HOSTNAME=192.168.24.178 \  -e MESOS_IP=192.168.24.178 \  -e MESOS_MASTER=zk://192.168.24.173:2181,192.168.24.179:2181,192.168.24.178:2181/mesos \  -e MESOS_LOG_DIR=/var/log/mesos \  -e MESOS_WORK_DIR=/var/tmp/mesos \  -v &quot;$(pwd)/log/mesos:/var/log/mesos&quot; \  -v &quot;$(pwd)/tmp/mesos:/var/tmp/mesos&quot; \  mesosphere/mesos-slave:1.6.1-rc2</code></pre><h3 id="Spark嵌入"><a href="#Spark嵌入" class="headerlink" title="Spark嵌入"></a>Spark嵌入</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker配合gitbook部署文档</title>
    <link href="undefined2019/12/11/gitbook%E6%96%87%E6%A1%A3%E9%83%A8%E7%BD%B2/"/>
    <url>2019/12/11/gitbook%E6%96%87%E6%A1%A3%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h4 id="安装gitbook"><a href="#安装gitbook" class="headerlink" title="安装gitbook"></a>安装gitbook</h4><pre><code>cnpm install -g gitbook-cli</code></pre><h4 id="构建目录结构"><a href="#构建目录结构" class="headerlink" title="构建目录结构"></a>构建目录结构</h4><pre><code>nginx-docker    --default.conf    --docker-compose.yml    --web        ---note</code></pre><h4 id="拉取文档仓库并编译"><a href="#拉取文档仓库并编译" class="headerlink" title="拉取文档仓库并编译"></a>拉取文档仓库并编译</h4><pre><code>git pull &amp;&amp; rm -rf _book &amp;&amp; gitbook install &amp;&amp; gitbook build .</code></pre><h4 id="编写nginx服务配置"><a href="#编写nginx服务配置" class="headerlink" title="编写nginx服务配置"></a>编写nginx服务配置</h4><pre><code>➜  nginx-docker cat default.conf server {  listen 80;  server_name xxx.xxx.xx.xxx;  root /web;  location /note {    alias /web/note/_book;    index index.html;  }  location  ^~ gitbook/ {    root /web/gitbook/;   }}</code></pre><h4 id="通过docker启动"><a href="#通过docker启动" class="headerlink" title="通过docker启动"></a>通过docker启动</h4><p>编写<code>docker-compse.yml</code></p><pre><code>➜  nginx-docker cat docker-compose.yml version: &#39;2&#39;services:  nginx:    image: nginx:latest    restart: always    container_name: nginx-web    network_mode: host    volumes:      - /var/run/docker.sock:/var/run/docker.sock      - ./web:/web      - ./default.conf:/etc/nginx/conf.d/default.conf</code></pre><h4 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h4><p>当执行<code>gitbook install</code>非常慢的时候，执行如下命令，变更npm安装源。</p><pre><code>sudo npm config set registry=http://registry.npm.taobao.org</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>通过docker搭建zookeeper</title>
    <link href="undefined2019/12/11/%E9%80%9A%E8%BF%87docker%E6%90%AD%E5%BB%BAzookeeper%E9%9B%86%E7%BE%A4/"/>
    <url>2019/12/11/%E9%80%9A%E8%BF%87docker%E6%90%AD%E5%BB%BAzookeeper%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://zookeeper.apache.org/doc/current/zookeeperStarted.html" target="_blank" rel="noopener">ZooKeeper Getting Started Guide</a><br><a href="https://blog.csdn.net/zhufuyi/article/details/72782350?locationNum=6&amp;fps=1" target="_blank" rel="noopener">Mesos+Zookeeper+Marathon的Docker管理平台部署记录</a><br><a href="http://blog.sina.com.cn/s/blog_8ea8e9d50102wx24.html" target="_blank" rel="noopener">docker部署zookeeper集群</a><br><a href="https://www.jianshu.com/p/14d30aa63dc9" target="_blank" rel="noopener">Docker环境搭建ZooKeeper集群</a></p><h2 id="环境组网"><a href="#环境组网" class="headerlink" title="环境组网"></a>环境组网</h2><h3 id="组网策略"><a href="#组网策略" class="headerlink" title="组网策略"></a>组网策略</h3><p>准备三台server搭建zookeeper最小化集群，以达成主备份关系，为后期mesos集群的管理和调度做准备</p><h3 id="节点主机配置"><a href="#节点主机配置" class="headerlink" title="节点主机配置"></a>节点主机配置</h3><p>储备三台服务器如下：<br>主机系统 | ip地址<br>—|—<br>ubuntu16.04 server | 192.168.24.173<br>ubuntu16.04 server | 192.168.24.179<br>ubuntu16.04 server | 192.168.24.178</p><h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><h3 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h3><h4 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h4><p>我们选择docker启动容器的方法来部署zookeeper，考虑到后期部署spark on mesos时版本的兼容性，这里选择zookeeper-3.4.13 。如下为集群的软件版本规划：<br>软件 | 版本<br>— | —<br>zookeeper | 3.4.13<br>mesos | 1.6.1<br>spark | 2.2.2</p><h4 id="zookeeper的docker容器选择"><a href="#zookeeper的docker容器选择" class="headerlink" title="zookeeper的docker容器选择"></a>zookeeper的docker容器选择</h4><p>在参阅 <a href="https://hub.docker.com/search/?isAutomated=0&amp;isOfficial=0&amp;page=1&amp;pullCount=0&amp;q=zookeeper&amp;starCount=0" target="_blank" rel="noopener">docker hub</a> 中的众多的zookeeper容器后，选择使用人群较多，dockerfile中版本配置比较新的 <a href="https://hub.docker.com/r/jplock/zookeeper/" target="_blank" rel="noopener">jplock/zookeeper:3.4.13</a> 作为本次集群搭建的zookeeper容器版本。  </p><h5 id="容器中的软件及版本"><a href="#容器中的软件及版本" class="headerlink" title="容器中的软件及版本"></a>容器中的软件及版本</h5><table><thead><tr><th>软件名</th><th>来源</th><th>版本</th></tr></thead><tbody><tr><td>jdk</td><td>openjdk:8-jre-alpine</td><td>jdk8</td></tr><tr><td>zookeeper</td><td><a href="http://apache.mirrors.pair.com" target="_blank" rel="noopener">http://apache.mirrors.pair.com</a></td><td>3.4.13</td></tr></tbody></table><h5 id="dockerFile"><a href="#dockerFile" class="headerlink" title="dockerFile"></a>dockerFile</h5><pre><code>FROM openjdk:8-jre-alpineARG MIRROR=http://apache.mirrors.pair.comARG VERSION=3.4.13LABEL name=&quot;zookeeper&quot; version=$VERSIONRUN apk add --no-cache wget bash \    &amp;&amp; mkdir -p /opt/zookeeper \    &amp;&amp; wget -q -O - $MIRROR/zookeeper/zookeeper-$VERSION/zookeeper-$VERSION.tar.gz \      | tar -xzC /opt/zookeeper --strip-components=1 \    &amp;&amp; cp /opt/zookeeper/conf/zoo_sample.cfg /opt/zookeeper/conf/zoo.cfg \    &amp;&amp; mkdir -p /tmp/zookeeperEXPOSE 2181 2888 3888WORKDIR /opt/zookeeper# Only checks if server is up and listening, not quorum. # See https://zookeeper.apache.org/doc/r3.4.13/zookeeperAdmin.html#sc_zkCommandsHEALTHCHECK CMD [ $(echo ruok | nc 127.0.0.1:2181) == &quot;imok&quot; ] || exit 1VOLUME [&quot;/opt/zookeeper/conf&quot;, &quot;/tmp/zookeeper&quot;]ENTRYPOINT [&quot;/opt/zookeeper/bin/zkServer.sh&quot;]CMD [&quot;start-foreground&quot;]</code></pre><h3 id="单个节点的配置"><a href="#单个节点的配置" class="headerlink" title="单个节点的配置"></a>单个节点的配置</h3><h4 id="zoo-cfg配置"><a href="#zoo-cfg配置" class="headerlink" title="zoo.cfg配置"></a>zoo.cfg配置</h4><pre><code>$ vi /conf/zoo.cfgtickTime=2000initLimit=5syncLimit=2#maxClientCnxns=60#autopurge.snapRetainCount=3#autopurge.purgeInterval=1dataDir=/opt/zookeeper/dataclientPort=2181server.1=192.168.24.173:2888:3888server.2=192.168.24.178:2888:3888server.3=192.168.24.179:2888:3888</code></pre><h4 id="myid配置"><a href="#myid配置" class="headerlink" title="myid配置"></a>myid配置</h4><p>在集群每个节点的zookeeper中修改或创建./data/myid文件，并在其中写入1~255之间的值，该值即为节点编号。</p><pre><code>$ mkdir data$ vi /data/myid1</code></pre><h3 id="拷贝容器配置到主机"><a href="#拷贝容器配置到主机" class="headerlink" title="拷贝容器配置到主机"></a>拷贝容器配置到主机</h3><pre><code>$ sudo docker container cp zk178:/opt/zookeeper/conf /opt/zookeeper$ sudo docker container cp zk178:/opt/zookeeper/data /opt/zookeeper</code></pre><h2 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h2><h3 id="启动参数策略"><a href="#启动参数策略" class="headerlink" title="启动参数策略"></a>启动参数策略</h3><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><pre><code>docker run -tid --restart=always \    --net=host \    -v /opt/zookeeper/data:/opt/zookeeper/data \    -v /opt/zookeeper/logs:/opt/zookeeper/logs \    -v /opt/zookeeper/conf:/opt/zookeeper/conf \    --name=zk173 \    jplock/zookeeper:3.4.13</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="测试命令："><a href="#测试命令：" class="headerlink" title="测试命令："></a>测试命令：</h4><p>通过如下命令测试集群是否联网正常。</p><pre><code>echo stat | nc 127.0.0.1 2181</code></pre><h4 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h4><pre><code>➜  ~ echo stat | nc 127.0.0.1 2181Zookeeper version: 3.4.13-2d71af4dbe22557fda74f9a9b4309b15a7487f03, built on 06/29/2018 04:05 GMTClients: /127.0.0.1:39122[0](queued=0,recved=1,sent=0)Latency min/avg/max: 0/0/0Received: 3Sent: 2Connections: 1Outstanding: 0Zxid: 0x10000000cMode: followerNode count: 8➜  ~ </code></pre><pre><code>topiot@iots2:~$ echo stat | nc 127.0.0.1 2181Zookeeper version: 3.4.13-2d71af4dbe22557fda74f9a9b4309b15a7487f03, built on 06/29/2018 04:05 GMTClients: /127.0.0.1:55782[1](queued=0,recved=1370,sent=1371) /127.0.0.1:55790[0](queued=0,recved=1,sent=0) /127.0.0.1:55780[1](queued=0,recved=1372,sent=1374) /127.0.0.1:55784[1](queued=0,recved=1371,sent=1373) /127.0.0.1:55778[1](queued=0,recved=1372,sent=1374)Latency min/avg/max: 0/0/81Received: 5639Sent: 5645Connections: 5Outstanding: 0Zxid: 0x10000000cMode: leaderNode count: 8Proposal sizes last/min/max: 36/36/338topiot@iots2:~$ </code></pre><pre><code>topiot@iots3:~$ echo stat | nc 127.0.0.1 2181Zookeeper version: 3.4.13-2d71af4dbe22557fda74f9a9b4309b15a7487f03, built on 06/29/2018 04:05 GMTClients: /127.0.0.1:39678[1](queued=0,recved=1390,sent=1390) /127.0.0.1:39680[1](queued=0,recved=1390,sent=1390) /127.0.0.1:39682[1](queued=0,recved=1390,sent=1390) /127.0.0.1:41312[0](queued=0,recved=1,sent=0)Latency min/avg/max: 0/0/74Received: 4326Sent: 4325Connections: 4Outstanding: 0Zxid: 0x10000000cMode: followerNode count: 8topiot@iots3:~$ </code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker Compose安装</title>
    <link href="undefined2019/12/11/Docker%20Compose%E5%AE%89%E8%A3%85/"/>
    <url>2019/12/11/Docker%20Compose%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker Compose"></a>安装 Docker Compose</h2><h4 id="官方安装方法"><a href="#官方安装方法" class="headerlink" title="官方安装方法"></a>官方安装方法</h4><ol><li>运行如下命令下载最新版本<pre><code>$ sudo curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose</code></pre></li><li>添加执行权限<pre><code>$ sudo chmod +x /usr/local/bin/docker-compose</code></pre></li><li><p>安装 <a href="https://docs.docker.com/compose/completion/" target="_blank" rel="noopener">completion</a> 以便能在bash和zsh的shell中运行completion命令（可选）</p></li><li><p>测试安装是否成功</p><pre><code>$ docker-compose --versiondocker-compose version 1.22.0, build 1719ceb</code></pre></li></ol><h4 id="加速通道安装"><a href="#加速通道安装" class="headerlink" title="加速通道安装"></a>加速通道安装</h4><p>Docker Compose 存放在Git Hub，不太稳定。<br>你可以也通过执行下面的命令，高速安装Docker Compose。</p><pre><code>$ sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose  $ sudo chmod +x /usr/local/bin/docker-compose  </code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://get.daocloud.io/#install-compose" target="_blank" rel="noopener">DaoCloud-install-compose</a><br><a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">Docker-install-compose</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>